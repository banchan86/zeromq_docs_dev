{
  "api/Bonsai.ZeroMQ.ConvertToFrame.html": {
    "href": "api/Bonsai.ZeroMQ.ConvertToFrame.html",
    "title": "Class ConvertToFrame | Bonsai.ZeroMQ",
    "keywords": "Class ConvertToFrame Namespace Bonsai.ZeroMQ Assembly Bonsai.ZeroMQ.dll Represents an operator that converts a sequence of data objects into a sequence of message frames. public class ConvertToFrame : Combinator<byte[], NetMQFrame> Inheritance object Combinator<byte[], NetMQFrame> ConvertToFrame Inherited Members Combinator<byte[], NetMQFrame>.Process(IObservable<byte[]>) object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Methods Process(IObservable<byte[]>) Converts a sequence of data buffers into an observable sequence of message frames. public override IObservable<NetMQFrame> Process(IObservable<byte[]> source) Parameters source IObservable<byte[]> A sequence of byte-array objects representing the individual data buffers. Returns IObservable<NetMQFrame> A sequence of NetMQ.NetMQFrame objects representing individual message frames. Process(IObservable<string>) Converts a sequence of string objects into an observable sequence of message frames. public IObservable<NetMQFrame> Process(IObservable<string> source) Parameters source IObservable<string> A sequence of string objects representing individual messages. Returns IObservable<NetMQFrame> A sequence of NetMQ.NetMQFrame objects encoding individual messages."
  },
  "api/Bonsai.ZeroMQ.ConvertToString.html": {
    "href": "api/Bonsai.ZeroMQ.ConvertToString.html",
    "title": "Class ConvertToString | Bonsai.ZeroMQ",
    "keywords": "Class ConvertToString Namespace Bonsai.ZeroMQ Assembly Bonsai.ZeroMQ.dll Represents an operator that converts a sequence of message frames into a sequence of strings using the default encoding. public class ConvertToString : Transform<NetMQFrame, string> Inheritance object Combinator<NetMQFrame, string> Transform<NetMQFrame, string> ConvertToString Inherited Members Combinator<NetMQFrame, string>.Process(IObservable<NetMQFrame>) object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Methods Process(IObservable<NetMQFrame>) Converts an observable sequence of message frames into a sequence of strings using the default encoding. public override IObservable<string> Process(IObservable<NetMQFrame> source) Parameters source IObservable<NetMQFrame> A sequence of NetMQ.NetMQFrame objects representing individual message frames. Returns IObservable<string> A sequence of strings extracted from each frame data buffer using the default encoding."
  },
  "api/Bonsai.ZeroMQ.Dealer.html": {
    "href": "api/Bonsai.ZeroMQ.Dealer.html",
    "title": "Class Dealer | Bonsai.ZeroMQ",
    "keywords": "Class Dealer Namespace Bonsai.ZeroMQ Assembly Bonsai.ZeroMQ.dll Represents an operator that creates a dealer socket for transmitting a sequence of messages and receiving responses asynchronously while maintaining load balance. public class Dealer : Combinator<NetMQMessage, NetMQMessage> Inheritance object Combinator<NetMQMessage, NetMQMessage> Dealer Inherited Members Combinator<NetMQMessage, NetMQMessage>.Process(IObservable<NetMQMessage>) object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties ConnectionString Gets or sets a value specifying the endpoints to attach the socket to. [TypeConverter(typeof(ConnectionStringConverter))] public string ConnectionString { get; set; } Property Value string Methods Process(IObservable<NetMQMessage>) Creates a dealer socket for transmitting an observable sequence of request messages and receiving responses asynchronously while maintaining load balance. public override IObservable<NetMQMessage> Process(IObservable<NetMQMessage> source) Parameters source IObservable<NetMQMessage> The sequence of multiple part request messages to transmit. Returns IObservable<NetMQMessage> An observable sequence of NetMQ.NetMQMessage objects representing multiple part responses received from the dealer socket. Process(IObservable<byte[]>) Creates a dealer socket for transmitting an observable sequence of binary-coded requests and receiving responses asynchronously while maintaining load balance. public IObservable<NetMQMessage> Process(IObservable<byte[]> source) Parameters source IObservable<byte[]> The sequence of binary-coded request messages to transmit. Returns IObservable<NetMQMessage> An observable sequence of NetMQ.NetMQMessage objects representing multiple part responses received from the dealer socket. Process(IObservable<string>) Creates a dealer socket for transmitting an observable sequence of string requests and receiving responses asynchronously while maintaining load balance. public IObservable<NetMQMessage> Process(IObservable<string> source) Parameters source IObservable<string> The sequence of string request messages to transmit. Returns IObservable<NetMQMessage> An observable sequence of NetMQ.NetMQMessage objects representing multiple part responses received from the dealer socket."
  },
  "api/Bonsai.ZeroMQ.GetIdentity.html": {
    "href": "api/Bonsai.ZeroMQ.GetIdentity.html",
    "title": "Class GetIdentity | Bonsai.ZeroMQ",
    "keywords": "Class GetIdentity Namespace Bonsai.ZeroMQ Assembly Bonsai.ZeroMQ.dll Represents an operator that extracts all the identity frames from each multiple part message in the sequence, up to and including the empty delimiter frame. public class GetIdentity : Combinator<NetMQMessage, NetMQFrame> Inheritance object Combinator<NetMQMessage, NetMQFrame> GetIdentity Inherited Members Combinator<NetMQMessage, NetMQFrame>.Process(IObservable<NetMQMessage>) object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Methods Process(IObservable<NetMQMessage>) Extracts all the identity frames from each multiple part message in an observable sequence, up to and including the empty delimiter frame. public override IObservable<NetMQFrame> Process(IObservable<NetMQMessage> source) Parameters source IObservable<NetMQMessage> An observable sequence of NetMQ.NetMQMessage objects representing the multiple part messages from which to extract the identity frames. Returns IObservable<NetMQFrame> A sequence of NetMQ.NetMQFrame objects representing all the identity frames in each message of the source sequence."
  },
  "api/Bonsai.ZeroMQ.ProxyBackend.html": {
    "href": "api/Bonsai.ZeroMQ.ProxyBackend.html",
    "title": "Class ProxyBackend | Bonsai.ZeroMQ",
    "keywords": "Class ProxyBackend Namespace Bonsai.ZeroMQ Assembly Bonsai.ZeroMQ.dll Represents an operator that creates and starts a proxy with the specified back-end socket. public class ProxyBackend : Combinator<SocketInfo, Unit>, INamedElement Inheritance object Combinator<SocketInfo, Unit> ProxyBackend Implements INamedElement Inherited Members Combinator<SocketInfo, Unit>.Process(IObservable<SocketInfo>) object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties ConnectionString Gets or sets a value specifying the endpoints to attach the socket to. [TypeConverter(typeof(ConnectionStringConverter))] public string ConnectionString { get; set; } Property Value string SocketType Gets or sets a value specifying the type of socket to use as the back-end for a proxy. public SocketType SocketType { get; set; } Property Value SocketType Methods Process(IObservable<SocketInfo>) Creates and starts a proxy with the specified back-end socket. public override IObservable<Unit> Process(IObservable<SocketInfo> source) Parameters source IObservable<SocketInfo> A sequence of SocketInfo objects representing information about the front-end socket to use for the proxy. A new proxy will be created and started for each value in the sequence. Returns IObservable<Unit> An observable sequence whose observers will never get called. The proxy is started purely for its side-effects of routing messages from the front-end to the back-end sockets."
  },
  "api/Bonsai.ZeroMQ.ProxyFrontend.html": {
    "href": "api/Bonsai.ZeroMQ.ProxyFrontend.html",
    "title": "Class ProxyFrontend | Bonsai.ZeroMQ",
    "keywords": "Class ProxyFrontend Namespace Bonsai.ZeroMQ Assembly Bonsai.ZeroMQ.dll Represents an operator that specifies the front-end socket for a proxy. public class ProxyFrontend : Source<SocketInfo>, INamedElement Inheritance object Source<SocketInfo> ProxyFrontend Implements INamedElement Inherited Members object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties ConnectionString Gets or sets a value specifying the endpoints to attach the socket to. [TypeConverter(typeof(ConnectionStringConverter))] public string ConnectionString { get; set; } Property Value string Remarks All messages from this endpoint will be forwarded into the proxy back-end. SocketType Gets or sets a value specifying the type of socket to use as the front-end for a proxy. public SocketType SocketType { get; set; } Property Value SocketType Methods Generate() Specifies the front-end socket for a proxy. public override IObservable<SocketInfo> Generate() Returns IObservable<SocketInfo> An observable sequence containing a single SocketInfo object representing information required for creating the front-end socket for a proxy."
  },
  "api/Bonsai.ZeroMQ.Publisher.html": {
    "href": "api/Bonsai.ZeroMQ.Publisher.html",
    "title": "Class Publisher | Bonsai.ZeroMQ",
    "keywords": "Class Publisher Namespace Bonsai.ZeroMQ Assembly Bonsai.ZeroMQ.dll Represents an operator that creates a publisher socket for transmitting a sequence of messages as part of the pub-sub pattern. public class Publisher : Sink<NetMQMessage> Inheritance object Combinator<NetMQMessage, NetMQMessage> Sink<NetMQMessage> Publisher Inherited Members Combinator<NetMQMessage, NetMQMessage>.Process(IObservable<NetMQMessage>) object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties ConnectionString Gets or sets a value specifying the endpoints to attach the socket to. [TypeConverter(typeof(ConnectionStringConverter))] public string ConnectionString { get; set; } Property Value string Topic Gets or sets the topic under which to publish each sent message. public string Topic { get; set; } Property Value string Methods Process(IObservable<NetMQMessage>) Creates a publisher socket for transmitting an observable sequence of multiple part messages. public override IObservable<NetMQMessage> Process(IObservable<NetMQMessage> source) Parameters source IObservable<NetMQMessage> The sequence of multiple part messages to transmit. Returns IObservable<NetMQMessage> An observable sequence that is identical to the source sequence but where there is an additional side effect of transmitting the multiple part messages over a publisher socket. Process(IObservable<byte[]>) Creates a publisher socket for transmitting an observable sequence of binary coded messages. public IObservable<byte[]> Process(IObservable<byte[]> source) Parameters source IObservable<byte[]> The sequence of binary coded messages to transmit. Returns IObservable<byte[]> An observable sequence that is identical to the source sequence but where there is an additional side effect of transmitting the binary coded messages over a publisher socket. Process(IObservable<string>) Creates a publisher socket for transmitting an observable sequence of string messages. public IObservable<string> Process(IObservable<string> source) Parameters source IObservable<string> The sequence of string messages to transmit. Returns IObservable<string> An observable sequence that is identical to the source sequence but where there is an additional side effect of transmitting the string messages over a publisher socket. See Also Subscriber"
  },
  "api/Bonsai.ZeroMQ.Pull.html": {
    "href": "api/Bonsai.ZeroMQ.Pull.html",
    "title": "Class Pull | Bonsai.ZeroMQ",
    "keywords": "Class Pull Namespace Bonsai.ZeroMQ Assembly Bonsai.ZeroMQ.dll Represents an operator that creates a pull socket for receiving a sequence of messages as part of the push-pull pattern. public class Pull : Source<NetMQMessage> Inheritance object Source<NetMQMessage> Pull Inherited Members object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties ConnectionString Gets or sets a value specifying the endpoints to attach the socket to. [TypeConverter(typeof(ConnectionStringConverter))] public string ConnectionString { get; set; } Property Value string Methods Generate() Creates a pull socket for receiving an observable sequence of multiple part messages as part of the push-pull pattern. public override IObservable<NetMQMessage> Generate() Returns IObservable<NetMQMessage> An observable sequence of NetMQ.NetMQMessage objects representing all multiple part messages received from the pull socket. See Also Push"
  },
  "api/Bonsai.ZeroMQ.Push.html": {
    "href": "api/Bonsai.ZeroMQ.Push.html",
    "title": "Class Push | Bonsai.ZeroMQ",
    "keywords": "Class Push Namespace Bonsai.ZeroMQ Assembly Bonsai.ZeroMQ.dll Represents an operator that creates a push socket for transmitting a sequence of messages as part of the push-pull pattern. public class Push : Sink<NetMQMessage> Inheritance object Combinator<NetMQMessage, NetMQMessage> Sink<NetMQMessage> Push Inherited Members Combinator<NetMQMessage, NetMQMessage>.Process(IObservable<NetMQMessage>) object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties ConnectionString Gets or sets a value specifying the endpoints to attach the socket to. [TypeConverter(typeof(ConnectionStringConverter))] public string ConnectionString { get; set; } Property Value string Methods Process(IObservable<NetMQMessage>) Creates a push socket for transmitting an observable sequence of multiple part messages. public override IObservable<NetMQMessage> Process(IObservable<NetMQMessage> source) Parameters source IObservable<NetMQMessage> The sequence of multiple part messages to transmit. Returns IObservable<NetMQMessage> An observable sequence that is identical to the source sequence but where there is an additional side effect of transmitting the multiple part messages over a push socket. Process(IObservable<byte[]>) Creates a push socket for transmitting an observable sequence of binary coded messages. public IObservable<byte[]> Process(IObservable<byte[]> source) Parameters source IObservable<byte[]> The sequence of binary coded messages to transmit. Returns IObservable<byte[]> An observable sequence that is identical to the source sequence but where there is an additional side effect of transmitting the binary coded messages over a push socket. Process(IObservable<string>) Creates a push socket for transmitting an observable sequence of string messages. public IObservable<string> Process(IObservable<string> source) Parameters source IObservable<string> The sequence of string messages to transmit. Returns IObservable<string> An observable sequence that is identical to the source sequence but where there is an additional side effect of transmitting the string messages over a push socket. See Also Pull"
  },
  "api/Bonsai.ZeroMQ.Request.html": {
    "href": "api/Bonsai.ZeroMQ.Request.html",
    "title": "Class Request | Bonsai.ZeroMQ",
    "keywords": "Class Request Namespace Bonsai.ZeroMQ Assembly Bonsai.ZeroMQ.dll Represents an operator that creates a request socket for transmitting a sequence of request messages and receiving responses as part of the req-rep pattern. public class Request : Combinator<byte[], NetMQMessage> Inheritance object Combinator<byte[], NetMQMessage> Request Inherited Members Combinator<byte[], NetMQMessage>.Process(IObservable<byte[]>) object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties ConnectionString Gets or sets a value specifying the endpoints to attach the socket to. [TypeConverter(typeof(ConnectionStringConverter))] public string ConnectionString { get; set; } Property Value string Methods Process(IObservable<NetMQMessage>) Creates a request socket for transmitting an observable sequence of multiple part request messages and returns all received responses. public IObservable<NetMQMessage> Process(IObservable<NetMQMessage> source) Parameters source IObservable<NetMQMessage> The sequence of multiple part request messages to transmit. Returns IObservable<NetMQMessage> An observable sequence of NetMQ.NetMQMessage objects representing multiple part responses received from the request socket. Process(IObservable<byte[]>) Creates a request socket for transmitting an observable sequence of binary-coded request messages and returns all received responses. public override IObservable<NetMQMessage> Process(IObservable<byte[]> source) Parameters source IObservable<byte[]> The sequence of binary-coded request messages to transmit. Returns IObservable<NetMQMessage> An observable sequence of NetMQ.NetMQMessage objects representing multiple part responses received from the request socket. Process(IObservable<string>) Creates a request socket for transmitting an observable sequence of string request messages and returns all received responses. public IObservable<NetMQMessage> Process(IObservable<string> source) Parameters source IObservable<string> The sequence of string request messages to transmit. Returns IObservable<NetMQMessage> An observable sequence of NetMQ.NetMQMessage objects representing multiple part responses received from the request socket."
  },
  "api/Bonsai.ZeroMQ.Response.html": {
    "href": "api/Bonsai.ZeroMQ.Response.html",
    "title": "Class Response | Bonsai.ZeroMQ",
    "keywords": "Class Response Namespace Bonsai.ZeroMQ Assembly Bonsai.ZeroMQ.dll Represents an operator that creates a response socket for receiving a sequence of request messages and transmitting generated responses. public class Response : Source<ResponseContext> Inheritance object Source<ResponseContext> Response Inherited Members object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties ConnectionString Gets or sets a value specifying the endpoints to attach the socket to. [TypeConverter(typeof(ConnectionStringConverter))] public string ConnectionString { get; set; } Property Value string Methods Generate() Creates a response socket for receiving an observable sequence of request messages and transmitting generated responses. public override IObservable<ResponseContext> Generate() Returns IObservable<ResponseContext> An observable sequence of ResponseContext objects representing received requests. Generate(IObservable<NetMQMessage>) Creates a response socket that returns all received requests and transmits an observable sequence of multiple part response messages. public IObservable<NetMQMessage> Generate(IObservable<NetMQMessage> source) Parameters source IObservable<NetMQMessage> The sequence of NetMQ.NetMQMessage objects representing the multiple part response messages to transmit. Returns IObservable<NetMQMessage> An observable sequence of NetMQ.NetMQMessage objects representing multiple part requests received from the response socket. Generate(IObservable<byte[]>) Creates a response socket that returns all received requests and transmits an observable sequence of binary-coded response messages. public IObservable<NetMQMessage> Generate(IObservable<byte[]> source) Parameters source IObservable<byte[]> The sequence of binary-coded response messages to transmit. Returns IObservable<NetMQMessage> An observable sequence of NetMQ.NetMQMessage objects representing multiple part requests received from the response socket. Generate(IObservable<string>) Creates a response socket that returns all received requests and transmits an observable sequence of string response messages. public IObservable<NetMQMessage> Generate(IObservable<string> source) Parameters source IObservable<string> The sequence of string response messages to transmit. Returns IObservable<NetMQMessage> An observable sequence of NetMQ.NetMQMessage objects representing multiple part requests received from the response socket. See Also SendResponse"
  },
  "api/Bonsai.ZeroMQ.ResponseContext.html": {
    "href": "api/Bonsai.ZeroMQ.ResponseContext.html",
    "title": "Class ResponseContext | Bonsai.ZeroMQ",
    "keywords": "Class ResponseContext Namespace Bonsai.ZeroMQ Assembly Bonsai.ZeroMQ.dll Represents a request message received by a response socket. public class ResponseContext Inheritance object ResponseContext Inherited Members object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties Request Gets the multiple part message representing the request message. public NetMQMessage Request { get; } Property Value NetMQMessage"
  },
  "api/Bonsai.ZeroMQ.Router.html": {
    "href": "api/Bonsai.ZeroMQ.Router.html",
    "title": "Class Router | Bonsai.ZeroMQ",
    "keywords": "Class Router Namespace Bonsai.ZeroMQ Assembly Bonsai.ZeroMQ.dll Represents an operator that creates a router socket for tracking the identity of received requests so that responses can be matched even if computed concurrently. public class Router : Source<ResponseContext> Inheritance object Source<ResponseContext> Router Inherited Members object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties ConnectionString Gets or sets a value specifying the endpoints to attach the socket to. [TypeConverter(typeof(ConnectionStringConverter))] public string ConnectionString { get; set; } Property Value string Methods Generate() Generates an observable sequence of requests received from a router socket, where the identity of each request is tracked so that responses can be matched even if computed concurrently. public override IObservable<ResponseContext> Generate() Returns IObservable<ResponseContext> An observable sequence of ResponseContext objects representing received requests. Generate(IObservable<NetMQMessage>) Creates a router socket that appends an identity to all received messages and reads it back from outgoing messages to determine the peer the message should be routed to. public IObservable<NetMQMessage> Generate(IObservable<NetMQMessage> source) Parameters source IObservable<NetMQMessage> The sequence of NetMQ.NetMQMessage objects representing the multiple part response messages to route back to peers. Returns IObservable<NetMQMessage> An observable sequence of NetMQ.NetMQMessage objects representing multiple part requests received from the router socket."
  },
  "api/Bonsai.ZeroMQ.SendResponse.html": {
    "href": "api/Bonsai.ZeroMQ.SendResponse.html",
    "title": "Class SendResponse | Bonsai.ZeroMQ",
    "keywords": "Class SendResponse Namespace Bonsai.ZeroMQ Assembly Bonsai.ZeroMQ.dll Represents an operator that computes the result of a remote request asynchronously and transmits the response through the corresponding socket. public class SendResponse : WorkflowExpressionBuilder, IWorkflowExpressionBuilder, INamedElement, IPropertyMappingBuilder, IExpressionBuilder Inheritance object ExpressionBuilder WorkflowExpressionBuilder SendResponse Implements IWorkflowExpressionBuilder INamedElement IPropertyMappingBuilder IExpressionBuilder Inherited Members WorkflowExpressionBuilder.BuildWorkflow(IEnumerable<Expression>, Expression, Func<Expression, Expression>) WorkflowExpressionBuilder.Name WorkflowExpressionBuilder.Description WorkflowExpressionBuilder.Workflow WorkflowExpressionBuilder.WorkflowDescriptor ExpressionBuilder.ToString() ExpressionBuilder.Unwrap(ExpressionBuilder) ExpressionBuilder.GetWorkflowElement(ExpressionBuilder) ExpressionBuilder.GetVisualizerElement(ExpressionBuilder) ExpressionBuilder.GetVisualizerMappings(ExpressionBuilder) ExpressionBuilder.FromWorkflowElement(object, ElementCategory) ExpressionBuilder.GetElementDisplayName(Type) ExpressionBuilder.GetElementDisplayName(object) object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Constructors SendResponse() Initializes a new instance of the SendResponse class. public SendResponse() SendResponse(ExpressionBuilderGraph) Initializes a new instance of the SendResponse class with the specified expression builder workflow. public SendResponse(ExpressionBuilderGraph workflow) Parameters workflow ExpressionBuilderGraph The expression builder workflow instance that will be used by this builder to generate the output expression tree. Properties ArgumentRange Gets the range of input arguments that this expression builder accepts. public override Range<int> ArgumentRange { get; } Property Value Range<int> Methods Build(IEnumerable<Expression>) Constructs an Expression node from a collection of input arguments. The result can be chained with other builders in a workflow. public override Expression Build(IEnumerable<Expression> arguments) Parameters arguments IEnumerable<Expression> A collection of Expression nodes representing the input arguments. Returns Expression The constructed Expression node."
  },
  "api/Bonsai.ZeroMQ.SocketInfo.html": {
    "href": "api/Bonsai.ZeroMQ.SocketInfo.html",
    "title": "Class SocketInfo | Bonsai.ZeroMQ",
    "keywords": "Class SocketInfo Namespace Bonsai.ZeroMQ Assembly Bonsai.ZeroMQ.dll Represents information required for creating a NetMQ.NetMQSocket. public class SocketInfo Inheritance object SocketInfo Inherited Members object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone()"
  },
  "api/Bonsai.ZeroMQ.SocketType.html": {
    "href": "api/Bonsai.ZeroMQ.SocketType.html",
    "title": "Enum SocketType | Bonsai.ZeroMQ",
    "keywords": "Enum SocketType Namespace Bonsai.ZeroMQ Assembly Bonsai.ZeroMQ.dll Specifies the basic types of message-queue sockets implementing the core patterns (pub-sub, req-rep, dealer-router, etc). public enum SocketType Fields Dealer = 5 Specifies a NetMQ.Sockets.DealerSocket. Pair = 0 Specifies a NetMQ.Sockets.PairSocket. Publisher = 1 Specifies a NetMQ.Sockets.PublisherSocket. Pull = 7 Specifies a NetMQ.Sockets.PullSocket. Push = 8 Specifies a NetMQ.Sockets.PushSocket. Request = 3 Specifies a NetMQ.Sockets.RequestSocket. Response = 4 Specifies a NetMQ.Sockets.ResponseSocket. Router = 6 Specifies a NetMQ.Sockets.RouterSocket. Stream = 11 Specifies a NetMQ.Sockets.StreamSocket. Subscriber = 2 Specifies a NetMQ.Sockets.SubscriberSocket. XPublisher = 9 Specifies a NetMQ.Sockets.XPublisherSocket. XSubscriber = 10 Specifies a NetMQ.Sockets.XSubscriberSocket."
  },
  "api/Bonsai.ZeroMQ.Subscriber.html": {
    "href": "api/Bonsai.ZeroMQ.Subscriber.html",
    "title": "Class Subscriber | Bonsai.ZeroMQ",
    "keywords": "Class Subscriber Namespace Bonsai.ZeroMQ Assembly Bonsai.ZeroMQ.dll Represents an operator that creates a subscriber socket for receiving a sequence of messages as part of the pub-sub pattern. public class Subscriber : Source<NetMQMessage> Inheritance object Source<NetMQMessage> Subscriber Inherited Members object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties ConnectionString Gets or sets a value specifying the endpoints to attach the socket to. [TypeConverter(typeof(ConnectionStringConverter))] public string ConnectionString { get; set; } Property Value string Topic Gets or sets the topic that the socket will subscribe to. public string Topic { get; set; } Property Value string Methods Generate() Creates a subscriber socket for receiving an observable sequence of multiple part messages on the specified Topic. public override IObservable<NetMQMessage> Generate() Returns IObservable<NetMQMessage> An observable sequence of NetMQ.NetMQMessage objects representing all multiple part messages received from the subscriber socket. See Also Publisher"
  },
  "api/Bonsai.ZeroMQ.ToMessage.html": {
    "href": "api/Bonsai.ZeroMQ.ToMessage.html",
    "title": "Class ToMessage | Bonsai.ZeroMQ",
    "keywords": "Class ToMessage Namespace Bonsai.ZeroMQ Assembly Bonsai.ZeroMQ.dll Represents an operator that creates a multiple part message from an observable sequence. public class ToMessage : Combinator<NetMQFrame, NetMQMessage> Inheritance object Combinator<NetMQFrame, NetMQMessage> ToMessage Inherited Members Combinator<NetMQFrame, NetMQMessage>.Process(IObservable<NetMQFrame>) object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Methods Process(IObservable<NetMQFrame>) Creates a multiple part message from an observable sequence of individual message frames. public override IObservable<NetMQMessage> Process(IObservable<NetMQFrame> source) Parameters source IObservable<NetMQFrame> A sequence of NetMQ.NetMQFrame objects representing the individual message parts. Returns IObservable<NetMQMessage> An observable sequence containing a single NetMQ.NetMQMessage object representing the created multiple part message. Process(IObservable<byte[]>) Creates a multiple part message from an observable sequence of individual data buffers. public IObservable<NetMQMessage> Process(IObservable<byte[]> source) Parameters source IObservable<byte[]> A sequence of byte-array objects representing the individual message parts. Returns IObservable<NetMQMessage> An observable sequence containing a single NetMQ.NetMQMessage object representing the created multiple part message. Process(IObservable<string>) Creates a multiple part message from an observable sequence of individual message parts. public IObservable<NetMQMessage> Process(IObservable<string> source) Parameters source IObservable<string> A sequence of string objects representing the individual message parts. Returns IObservable<NetMQMessage> An observable sequence containing a single NetMQ.NetMQMessage object representing the created multiple part message."
  },
  "api/Bonsai.ZeroMQ.html": {
    "href": "api/Bonsai.ZeroMQ.html",
    "title": "Namespace Bonsai.ZeroMQ | Bonsai.ZeroMQ",
    "keywords": "Namespace Bonsai.ZeroMQ Classes ConvertToFrame Represents an operator that converts a sequence of data objects into a sequence of message frames. ConvertToString Represents an operator that converts a sequence of message frames into a sequence of strings using the default encoding. Dealer Represents an operator that creates a dealer socket for transmitting a sequence of messages and receiving responses asynchronously while maintaining load balance. GetIdentity Represents an operator that extracts all the identity frames from each multiple part message in the sequence, up to and including the empty delimiter frame. ProxyBackend Represents an operator that creates and starts a proxy with the specified back-end socket. ProxyFrontend Represents an operator that specifies the front-end socket for a proxy. Publisher Represents an operator that creates a publisher socket for transmitting a sequence of messages as part of the pub-sub pattern. Pull Represents an operator that creates a pull socket for receiving a sequence of messages as part of the push-pull pattern. Push Represents an operator that creates a push socket for transmitting a sequence of messages as part of the push-pull pattern. Request Represents an operator that creates a request socket for transmitting a sequence of request messages and receiving responses as part of the req-rep pattern. Response Represents an operator that creates a response socket for receiving a sequence of request messages and transmitting generated responses. ResponseContext Represents a request message received by a response socket. Router Represents an operator that creates a router socket for tracking the identity of received requests so that responses can be matched even if computed concurrently. SendResponse Represents an operator that computes the result of a remote request asynchronously and transmits the response through the corresponding socket. SocketInfo Represents information required for creating a NetMQ.NetMQSocket. Subscriber Represents an operator that creates a subscriber socket for receiving a sequence of messages as part of the pub-sub pattern. ToMessage Represents an operator that creates a multiple part message from an observable sequence. Enums SocketType Specifies the basic types of message-queue sockets implementing the core patterns (pub-sub, req-rep, dealer-router, etc)."
  },
  "articles/overview.html": {
    "href": "articles/overview.html",
    "title": "| Bonsai.ZeroMQ",
    "keywords": "Bonsai.ZeroMQ is a Bonsai interface for ZeroMQ providing a flexible networking and messaging library for coordinating distributed processing. The core patterns discussed in the ØMQ Guide are exposed via reactive operators and discussed in detail in the Patterns chapter. You can use Bonsai.ZeroMQ to transmit requests and data across different workflows running in the same computer, or in a different computer. You can also use the package to create endpoints for interfacing Bonsai with other languages supporting ZeroMQ. Installing the package To install Bonsai.ZeroMQ use the Bonsai package manager and search for the Bonsai - ZeroMQ package."
  },
  "articles/patterns.html": {
    "href": "articles/patterns.html",
    "title": "Patterns | Bonsai.ZeroMQ",
    "keywords": "Patterns ZeroMQ provides a set of sockets and patterns for building distributed systems. We have adapted these patterns to fit neatly into the Bonsai visual language by defining a set of reactive operators named after each socket type. Pattern Description Operators Publish-Subscribe One to many data distribution Publisher, Subscriber Request-Response Remote procedure call Request, Response Router-Dealer Asynchronous requests from multiple clients Router, Dealer Push-Pull Fan-out / fan-in task distribution Push, Pull Proxy Broker / intermediation patterns ProxyFrontend, ProxyBackend Each section in this chapter describes a basic ZeroMQ messaging pattern, usually involving complementary pairs of sockets, and provides examples of use that you can copy and paste directly into the editor."
  },
  "articles/proxy.html": {
    "href": "articles/proxy.html",
    "title": "Proxy | Bonsai.ZeroMQ",
    "keywords": "Proxy (Intermediation) The basic messaging patterns in ZeroMQ use direct connections between socket endpoints. The role of proxies, or intermediaries, is to abstract away direct references between endpoints, replacing them by references to the proxy. The proxy itself is specified by exposing a ProxyFrontend socket and a ProxyBackend socket. All primary messages are routed from front-end to back-end, but secondary responses or subscription messages can also flow from back-end to front-end as required by the specified socket types. This enables easily building variants of the basic patterns where peers are discovered dynamically or pools of clients and services can join and leave at any time, with the only constraint that all message passing is stateless. The examples below illustrate some of the most common proxy patterns. Example: Extended Publish-Subscribe In the basic Publish-Subscribe pattern, a set of subscribers connect to a single publisher. Typically the publisher binds to its endpoint and does not know the identity of the subscribers. However, all subscribers have to know the identity of the publisher endpoint. This makes it hard to replace the publisher, or to allow for multiple publishers to push data to subscribers. The extended publish-subscribe pattern allows for dynamic discovery of both publishers and subscribers by introducing a proxy. This way, publishers do not need to know the identity of subscribers, and subscribers do not need to know the identity of publishers. Only the identity of the proxy endpoints is required. graph LR A(Publisher) ---|PUB| D(<p></p>) B(Publisher) ---|PUB| D(<p></p>) C(Publisher) ---|PUB| D(<p></p>) D ---|XSUB| E(Proxy) E ---|XPUB| F(<p></p>) F -->|SUB| G(Subscriber) F -->|SUB| H(Subscriber) F -->|SUB| I(Subscriber) The proxy needs to be configured with a XSubscriber as the front-end socket, and a XPublisher as the back-end socket. In the example below, two timers publish periodic updates to an unknown set of subscribers using this proxy pattern. Example: Extended Request-Response In the basic Request-Response pattern, one client connects to a single server. We can also use Router-Dealer patterns so that multiple asynchronous requests can be handled in parallel by the server. However, in both cases we assume there is a single endpoint for handling service requests which is known by all clients. The extended request-response pattern allows for clusters of workers to dynamically join or leave a shared message queue, and handle requests from existing clients as they arrive. The client connects to the proxy front-end, and workers to the proxy back-end. This way we can scale up the number of workers without having to change anything about the clients. graph LR A(Client) ---|REQ| D(<p></p>) B(Client) ---|REQ| D(<p></p>) C(Client) ---|REQ| D(<p></p>) D ---|Router| E(Proxy) E ---|Dealer| F(<p></p>) F -->|REP| G(Worker) F -->|REP| H(Worker) F -->|REP| I(Worker) The shared queue is simply a proxy configured with a Router as the front-end socket, and a Dealer as the back-end socket. In the example below, a timer sends periodic requests to the shared queue, and workers alternate servicing the requests. Each reply is tagged with the identity of the worker who handled the request for easy visualization."
  },
  "articles/pub-sub.html": {
    "href": "articles/pub-sub.html",
    "title": "Publish-Subscribe | Bonsai.ZeroMQ",
    "keywords": "Publish-Subscribe The publish-subscribe (pub-sub) pattern implements one-way data distribution, in which a Publisher node pushes a stream of updates to a set of Subscriber nodes. Messages pushed by the publisher are sent to all subscribers active at the moment of sending the message. graph LR A(Publisher) ---|PUB| B(<p></p>) B -->|SUB| D(Subscriber) B -->|SUB| E(Subscriber) B -->|SUB| F(Subscriber) Distribution is fully asynchronous, and publisher and subscriber nodes can be started in any order. Publisher nodes may specify a Topic for each sent message. When connecting to a publisher, subscriber nodes can subscribe to one or more topics. If no topic is specified, subscriber nodes will receive all messages from the publisher. Warning Subscriber nodes are not guaranteed to receive the same number of messages sent by the publisher or by other subscribers. Initializing a connection to the publisher can take long enough that messages already being sent are lost, so it is best to assume that pub-sub streams are infinite streams with no beginning or end. Example: Simple publish-subscribe stream In the example below, a periodic timer publishes counter updates with multiple downstream subscribers. The numeric data is formatted as a string message for transmission, and parsed back on reception."
  },
  "articles/push-pull.html": {
    "href": "articles/push-pull.html",
    "title": "Push-Pull | Bonsai.ZeroMQ",
    "keywords": "Push-Pull (Pipeline) The pipeline (push-pull) pattern is intended for task distribution in a fan-out (one-to-many) or fan-in (many-to-one) pattern. The Push operator is used to distribute messages to a set of anonymous peers using a round-robin algorithm. Peers use a Pull source to receive tasks using a fair-queue algorithm. The most common application of the pipeline pattern is to implement divide-and-conquer strategies, where a node (Ventilator) divides a large computation into smaller sub-tasks which are distributed to a pool of Workers. All results are then pushed to be aggregated by a collector (Sink). graph LR A(Ventilator) ---|PUSH| B(<p></p>) B -->|PULL| D(Worker) B -->|PULL| E(Worker) B -->|PULL| F(Worker) D ---|PUSH| G(<p></p>) E ---|PUSH| G F ---|PUSH| G G -->|PULL| H(Sink) Messages are not discarded even if no worker nodes are available to process tasks, and new nodes can join the pattern at any time. Warning Messages may be lost if a worker node crashes in the middle of processing its chunk, or during transmission of a task. Feedback strategies at the level of the collector may be used to mitigate for such failures if necessary. Example: Fan-out task distribution In the example below, a periodic timer distributes unique identifiers to anonymous worker peers. Notice that each identifier is pulled by one and only one worker, using a round-robin strategy."
  },
  "articles/recipes.html": {
    "href": "articles/recipes.html",
    "title": "Recipes | Bonsai.ZeroMQ",
    "keywords": "Recipes This section contains a collection of recipes for working with ZeroMQ in Bonsai. It goes beyond the basic patterns discussed earlier in the manual, and touches on problems of interfacing ZeroMQ with other packages, which might come up when you actually try to use the library for specific applications. Video streams The Vision package provides the EncodeImage and DecodeImage operators to compress raw image frames into byte streams using a variety of common compression algorithms. The example below shows how to create a simple video streaming server using the Publish-Subscribe pattern. Binary data ZeroMQ can be used as a transport protocol for other binary-coded data representations. The example below shows how to use the Format and Parse operators in the OSC package to transmit complex types over byte streams, while using ZeroMQ to allow more flexible networking patterns."
  },
  "articles/req-rep.html": {
    "href": "articles/req-rep.html",
    "title": "Request-Response | Bonsai.ZeroMQ",
    "keywords": "Request-Response The request-response (req-rep) pattern is used to connect a set of clients to a set of services. It can also be seen as a form of remote procedure call and a simple task distribution pattern. graph LR C(Client) C -->|REQ| D(Server) D -->|REP| C On the client side, messages containing the details of each procedure call are pushed by each client using a Request node. On the server side, a Response node is used to receive notifications of new requests. Responses can be evaluated using the SendResponse operator. Warning This pattern is strictly sequential: if multiple requests are sent to a Response socket, they will be handled by the server one at a time, in order of arrival. For asynchronous processing of requests, see the Router-Dealer pattern. Example: Simple request-response In the example below, a periodic timer sends counter updates as a request to the server. The server replies by formatting the input string with the prefix reply."
  },
  "articles/router-dealer.html": {
    "href": "articles/router-dealer.html",
    "title": "Router-Dealer | Bonsai.ZeroMQ",
    "keywords": "Router-Dealer In the Request-Response pattern we typically have one client sending requests to a single server. However, in practice we often need to allow multiple requests to be processed in parallel by the server. We can use a Router socket to achieve this. graph LR A(Client) -- REQ --> D B(Client) -- REQ --> D C(Client) -- REQ --> D D(Router) -- id:REQ --> E E(Worker) -- id:REP --> D On the client side, requests are sent using a Request node as normal, but now with multiple clients sending requests. On the server side, a Router node is used to dispatch notifications of new requests to workers. Responses can be evaluated asynchronously using the SendResponse operator. Warning Requests dispatched by the router are prefixed with one or more identity frames that uniquely specify the client to which the response must be sent. Responses must preserve these frames to ensure that messages can be routed back to the client. Example: Asynchronous request-response In the example below, multiple clients send periodic requests to an asynchronous server. The server replies by formatting the input string with the prefix reply. Content frames are stored after the empty delimiter frame. For simple requests this is usually the last frame, which can be retrieved directly using the Last property. The SendResponse operator automatically takes care of pushing all identity frames from the request into the response to generate an outgoing message ready to be routed."
  },
  "index.html": {
    "href": "index.html",
    "title": "Getting Started | Bonsai.ZeroMQ",
    "keywords": "Getting Started Bonsai.ZeroMQ is a Bonsai interface for ZeroMQ providing a flexible networking and messaging library for coordinating distributed processing. The core patterns discussed in the ØMQ Guide are exposed via reactive operators and discussed in detail in the Patterns chapter. You can use Bonsai.ZeroMQ to transmit requests and data across different workflows running in the same computer, or in a different computer. You can also use the package to create endpoints for interfacing Bonsai with other languages supporting ZeroMQ. Installing the package To install Bonsai.ZeroMQ use the Bonsai package manager and search for the Bonsai - ZeroMQ package. Warning These docs are under active development, feel free to contribute by either raising an issue or following the links to Improve this Doc."
  }
}